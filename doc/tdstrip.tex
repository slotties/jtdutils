\subsection{tdstrip}

The first tool you need is tdstrip.
It reads a log file and prints all found thread dumps in an XML format, which again is parsed by the other tools.
Currently the tool only supports thread dumps of SUN JVM's 1.4 to 1.6 and IBMv9.
The \inlineCode{--type} parameter allows you to define the parser.
The default is \textbf{sun}.
If you want to parse one or many IBM thread dump files, so called javacore files, you should call tdstrip with \inlineCode{--type ibm}.

\subsubsection{Format}

For example you have this thread dump:
\begin{lstlisting}
2009-03-06 21:40:43
Full thread dump Java HotSpot(TM) 64-Bit Server VM (10.0-b19 mixed mode):

"TimerQueue" daemon prio=10 tid=0x00007f88fc0f0000 nid=0x1cc7 in Object.wait() [...]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x00007f88e70b1810> (a javax.swing.TimerQueue)
        at javax.swing.TimerQueue.run(TimerQueue.java:236)
        - locked <0x00007f88e70b1810> (a javax.swing.TimerQueue)
        at java.lang.Thread.run(Thread.java:619)
\end{lstlisting}

tdstrip converts that into this here:
\begin{lstlisting}
<?xml version="1.0"?>
<dumps>
<dump id="2009-03-06 21:40:43">
<thread name="TimerQueue" state="OBJ_WAIT" native_id="0x1cc7" java_id="0x00007f88fc0f0000">
<stacktrace>
<code class="java.lang.Object.wait" file="NATIVE" line="-1"/>
<lock id="0x00007f88e70b181" class="javax.swing.TimerQueue" isOwner="0"/>
<code class="javax.swing.TimerQueue.run" file="TimerQueue.java" line="236"/>
<lock id="0x00007f88e70b181" class="javax.swing.TimerQueue" isOwner="1"/>
<code class="java.lang.Thread.run" file="Thread.java" line="619"/>
</stacktrace>
</thread>
</dump>
</dumps>
\end{lstlisting}

Each dump is represented by a \inlineCode{dump} node having an ID.
In SUN JVM 1.4 the ID is an increasing counter starting at 0, just like an index.
In newer SUN JVM's the timestamp before a thread dump is used.

A thread has these attributes:

\begin{description}
\item[name] is the thread name which can be set when creating a thread in java\footnote{http://java.sun.com/javase/6/docs/api/java/lang/Thread.html\#Thread(java.lang.Runnable,\%20java.lang.String)}.
\item[state] is the current thread state. The states are defined in Thread.State\footnote{http://java.sun.com/javase/6/docs/api/java/lang/Thread.State.html}.
The transport format mapped all states to own, JVM independent string representations:
% FIXME: more detailled information, map to sun jvm states
	\begin{description}
		\item[RUN] for currently running threads.
		\item[OBJ\_WAIT] for threads which wait on an object.
		\item[WAIT\_COND] for threads waiting on a condition.
		\item[WAIT\_MON] for threads waiting on a monitor.
		\item[SLEEP] for sleeping threads.
		\item[UNKNOWN] for unmapped states. In this case please send me an e-mail containing the JVM dump of this single thread.
	\end{description}
\item[native\_id] is the native thread PID in hex.
\item[java\_id] is the JVM internal PID in hex.
\end{description}

and a \inlineCode{stacktrace} node.
This node has currently two possible child nodes: \inlineCode{code} and \inlineCode{lock}.
A \inlineCode{code} node represents a standard code line in the stack and has these attributes:

\begin{description}
\item[class] The code line (full qualified class name and method name, just like in the stacktrace).
\item[file] The source file. For native calls file will always contain 'NATIVE'.
\item[line] The line in the source file. For native calls line will always be -1.
\end{description}

A \inlineCode{lock} node represents a lock or park and has these attributes:

\begin{description}
\item[class] The class of the lock object.
\item[id] The lock object ID/address.
\item[isOwner] Is 0 (false) or 1 (true) and defines if the lock line defines a lock-owner or someone waiting for the lock.
\end{description}

The whole output is written to standard out.
Usually you just pipe it to the other tools which then do their work.

\subsubsection{Why XML?}
Well, until version 0.4 the question was 'Why \textbf{not} XML?'.
Back then I thought it was better to have an own format.
But after a few months I got more thoughts about re-using the output of tdstrip, e.g. for analysis using XML transformation.
The XML parser is not written by myself.
It's actually expat\footnote{http://expat.sourceforge.net} and I really like it.
